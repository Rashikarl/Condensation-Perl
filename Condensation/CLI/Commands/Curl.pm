# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node001 = CDS::Parser::Node->new(1);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(0);
	my $node011 = CDS::Parser::Node->new(0);
	my $node012 = CDS::Parser::Node->new(0);
	my $node013 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlGet});
	my $node014 = CDS::Parser::Node->new(0);
	my $node015 = CDS::Parser::Node->new(0);
	my $node016 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlPut});
	my $node017 = CDS::Parser::Node->new(0);
	my $node018 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlBook});
	my $node019 = CDS::Parser::Node->new(0);
	my $node020 = CDS::Parser::Node->new(0);
	my $node021 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlList});
	my $node022 = CDS::Parser::Node->new(0);
	my $node023 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlGet});
	my $node024 = CDS::Parser::Node->new(0);
	my $node025 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlPut});
	my $node026 = CDS::Parser::Node->new(0);
	my $node027 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlBook});
	my $node028 = CDS::Parser::Node->new(0);
	my $node029 = CDS::Parser::Node->new(1);
	my $node030 = CDS::Parser::Node->new(0);
	my $node031 = CDS::Parser::Node->new(0);
	my $node032 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlList});
	my $node033 = CDS::Parser::Node->new(0);
	my $node034 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlGet});
	my $node035 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlPut});
	my $node036 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlBook});
	my $node037 = CDS::Parser::Node->new(1);
	my $node038 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlList});
	my $node039 = CDS::Parser::Node->new(0);
	my $node040 = CDS::Parser::Node->new(0);
	my $node041 = CDS::Parser::Node->new(0);
	my $node042 = CDS::Parser::Node->new(0);
	my $node043 = CDS::Parser::Node->new(0);
	my $node044 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlList});
	my $node045 = CDS::Parser::Node->new(1);
	my $node046 = CDS::Parser::Node->new(0);
	my $node047 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlModify});
	my $node048 = CDS::Parser::Node->new(0);
	my $node049 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlModify});
	my $node050 = CDS::Parser::Node->new(0);
	my $node051 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&curlModify});
	$cds->addArrow($node001, 1, 0, 'curl');
	$help->addArrow($node000, 1, 0, 'curl');
	$node001->addArrow($node002, 1, 0, 'get');
	$node001->addArrow($node003, 1, 0, 'put');
	$node001->addArrow($node004, 1, 0, 'book');
	$node001->addArrow($node005, 1, 0, 'get');
	$node001->addArrow($node006, 1, 0, 'book');
	$node001->addArrow($node007, 1, 0, 'list');
	$node001->addArrow($node007, 1, 0, 'watch', \&collectWatch);
	$node001->addDefault($node011);
	$node002->addArrow($node013, 1, 0, 'HASH', \&collectHash);
	$node003->addArrow($node016, 1, 0, 'FILE', \&collectFile);
	$node004->addArrow($node018, 1, 0, 'HASH', \&collectHash);
	$node005->addArrow($node023, 1, 0, 'OBJECT', \&collectObject);
	$node006->addArrow($node027, 1, 0, 'OBJECT', \&collectObject);
	$node007->addArrow($node008, 1, 0, 'message');
	$node007->addArrow($node009, 1, 0, 'private');
	$node007->addArrow($node010, 1, 0, 'public');
	$node007->addArrow($node021, 0, 0, 'messages', \&collectMessages);
	$node007->addArrow($node021, 0, 0, 'private', \&collectPrivate);
	$node007->addArrow($node021, 0, 0, 'public', \&collectPublic);
	$node008->addArrow($node021, 1, 0, 'box', \&collectMessages);
	$node009->addArrow($node021, 1, 0, 'box', \&collectPrivate);
	$node010->addArrow($node021, 1, 0, 'box', \&collectPublic);
	$node011->addArrow($node012, 1, 0, 'remove');
	$node011->addArrow($node020, 1, 0, 'add');
	$node012->addArrow($node012, 1, 0, 'HASH', \&collectHash1);
	$node012->addArrow($node037, 1, 0, 'HASH', \&collectHash1);
	$node013->addArrow($node014, 1, 0, 'from');
	$node013->addArrow($node015, 0, 0, 'on');
	$node013->addDefault($node023);
	$node014->addArrow($node023, 1, 0, 'STORE', \&collectStore);
	$node015->addArrow($node023, 0, 0, 'STORE', \&collectStore);
	$node016->addArrow($node017, 1, 0, 'onto');
	$node016->addDefault($node025);
	$node017->addArrow($node025, 1, 0, 'STORE', \&collectStore);
	$node018->addArrow($node019, 1, 0, 'on');
	$node018->addDefault($node027);
	$node019->addArrow($node027, 1, 0, 'STORE', \&collectStore);
	$node020->addArrow($node029, 1, 0, 'FILE', \&collectFile1);
	$node020->addArrow($node029, 1, 0, 'HASH', \&collectHash2);
	$node021->addArrow($node022, 1, 0, 'of');
	$node022->addArrow($node032, 1, 0, 'ACTOR', \&collectActor);
	$node023->addArrow($node024, 1, 0, 'using');
	$node024->addArrow($node034, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node025->addArrow($node026, 1, 0, 'using');
	$node026->addArrow($node035, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node027->addArrow($node028, 1, 0, 'using');
	$node028->addArrow($node036, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node029->addDefault($node020);
	$node029->addArrow($node030, 1, 0, 'and');
	$node029->addArrow($node040, 1, 0, 'to');
	$node030->addArrow($node031, 1, 0, 'remove');
	$node031->addArrow($node031, 1, 0, 'HASH', \&collectHash1);
	$node031->addArrow($node037, 1, 0, 'HASH', \&collectHash1);
	$node032->addArrow($node033, 1, 0, 'on');
	$node033->addArrow($node038, 1, 0, 'STORE', \&collectStore);
	$node037->addArrow($node040, 1, 0, 'from');
	$node038->addArrow($node039, 1, 0, 'using');
	$node039->addArrow($node044, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node040->addArrow($node041, 1, 0, 'message');
	$node040->addArrow($node042, 1, 0, 'private');
	$node040->addArrow($node043, 1, 0, 'public');
	$node040->addArrow($node045, 0, 0, 'messages', \&collectMessages1);
	$node040->addArrow($node045, 0, 0, 'private', \&collectPrivate1);
	$node040->addArrow($node045, 0, 0, 'public', \&collectPublic1);
	$node041->addArrow($node045, 1, 0, 'box', \&collectMessages1);
	$node042->addArrow($node045, 1, 0, 'box', \&collectPrivate1);
	$node043->addArrow($node045, 1, 0, 'box', \&collectPublic1);
	$node045->addArrow($node046, 1, 0, 'of');
	$node045->addDefault($node047);
	$node046->addArrow($node047, 1, 0, 'ACTOR', \&collectActor1);
	$node047->addArrow($node011, 1, 0, 'and', \&collectAnd);
	$node047->addArrow($node048, 1, 0, 'on');
	$node048->addArrow($node049, 1, 0, 'STORE', \&collectStore);
	$node049->addArrow($node050, 1, 0, 'using');
	$node050->addArrow($node051, 1, 0, 'KEYPAIR', \&collectKeypair);
}

sub collectActor($o, $label, $value) {
	$o:actorHash = $value;
}

sub collectActor1($o, $label, $value) {
	$o:currentBatch:actorHash = $value;
}

sub collectAnd($o, $label, $value) {
	push @$o:batches, $o:currentBatch;
	$o:currentBatch = {
	addHashes => [],
	addEnvelopes => [],
	removeHashes => []
	};
}

sub collectFile($o, $label, $value) {
	$o:file = $value;
}

sub collectFile1($o, $label, $value) {
	push @$o:currentBatch:addFiles, $value;
}

sub collectHash($o, $label, $value) {
	$o:hash = $value;
}

sub collectHash1($o, $label, $value) {
	push @$o:currentBatch:removeHashes, $value;
}

sub collectHash2($o, $label, $value) {
	push @$o:currentBatch:addHashes, $value;
}

sub collectKeypair($o, $label, $value) {
	$o:keyPairToken = $value;
}

sub collectMessages($o, $label, $value) {
	$o:boxLabel = 'messages';
}

sub collectMessages1($o, $label, $value) {
	$o:currentBatch:boxLabel = 'messages';
}

sub collectObject($o, $label, $value) {
	$o:hash = $value->hash;
	$o:store = $value->cliStore;
}

sub collectPrivate($o, $label, $value) {
	$o:boxLabel = 'private';
}

sub collectPrivate1($o, $label, $value) {
	$o:currentBatch:boxLabel = 'private';
}

sub collectPublic($o, $label, $value) {
	$o:boxLabel = 'public';
}

sub collectPublic1($o, $label, $value) {
	$o:currentBatch:boxLabel = 'public';
}

sub collectStore($o, $label, $value) {
	$o:store = $value;
}

sub collectWatch($o, $label, $value) {
	$o:watchTimeout = 60000;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME curl
# HTML TITLE Curl
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->p($ui->blue('cds curl'), ' prepares and executes a CURL command line for a HTTP store request. This is helpful for debugging a HTTP store implementation. Outside of low-level debugging, it is more convenient to use the "cds get|put|list|add|remove …" commands, which are richer in functionality, and work on all stores.');
	$ui->space;
	$ui->command('cds curl get OBJECT');
	$ui->command('cds curl get HASH [from|on STORE]');
	$ui->p('Downloads an object with a GET request on an object store.');
	$ui->space;
	$ui->command('cds curl put FILE [onto STORE]');
	$ui->p('Uploads an object with a PUT request on an object store.');
	$ui->space;
	$ui->command('cds curl book OBJECT');
	$ui->command('cds curl book HASH [on STORE]');
	$ui->p('Books an object with a POST request on an object store.');
	$ui->space;
	$ui->command('cds curl list message box of ACTOR [on STORE]');
	$ui->command('cds curl list private box of ACTOR [on STORE]');
	$ui->command('cds curl list public box of ACTOR [on STORE]');
	$ui->p('Lists the indicated box with a GET request on an account store.');
	$ui->space;
	$ui->command('cds curl watch message box of ACTOR [on STORE]');
	$ui->command('cds curl watch private box of ACTOR [on STORE]');
	$ui->command('cds curl watch public box of ACTOR [on STORE]');
	$ui->p('As above, but with a watch timeout of 60 second.');
	$ui->space;
	$ui->command('cds curl add (FILE|HASH)* to (message|private|public) box of ACTOR [and …] [on STORE]');
	$ui->command('cds curl remove HASH* from (message|private|public) box of ACTOR [and …] [on STORE]');
	$ui->p('Modifies the indicated boxes with a POST request on an account store. Multiple modifications to different boxes may be chained using "and". All modifications are submitted using a single request, which is optionally signed (see below).');
	$ui->space;
	$ui->command('… using KEYPAIR');
	$ui->p('Signs the request using KEYPAIR instead of the actor\'s key pair. The store may or may not verify the signature.');
	$ui->p('For debugging purposes, information about the signature is stored as ".cds-curl-bytes-to-sign", ".cds-curl-hash-to-sign", and ".cds-curl-signature" in the current folder. Note that signatures are valid for 1-2 minutes only. After that, servers will reject them to guard against replay attacks.');
	$ui->space;
}

sub curlGet($o, $cmd) {
	$cmd->collect($o);
	$o:keyPairToken = $o:actor->preferredKeyPairToken if ! $o:keyPairToken;
	$o:store = $o:actor->preferredStore if ! $o:store;

	my $objectToken = CDS::ObjectToken->new($o:store, $o:hash);
	$o->curlRequest('GET', $objectToken->url, ['--output', $o:hash->hex]);
}

sub curlPut($o, $cmd) {
	$cmd->collect($o);
	$o:keyPairToken = $o:actor->preferredKeyPairToken if ! $o:keyPairToken;
	$o:store = $o:actor->preferredStore if ! $o:store;

	my $bytes = CDS->readBytesFromFile($o:file) // return $o:ui->error('Unable to read "', $o:file, '".');
	my $hash = CDS::Hash->calculateFor($bytes);
	my $objectToken = CDS::ObjectToken->new($o:store, $hash);
	$o->curlRequest('PUT', $objectToken->url, ['--data-binary', '@'.$o:file, '-H', 'Content-Type: application/condensation-object']);
}

sub curlBook($o, $cmd) {
	$cmd->collect($o);
	$o:keyPairToken = $o:actor->preferredKeyPairToken if ! $o:keyPairToken;
	$o:store = $o:actor->preferredStore if ! $o:store;

	my $objectToken = CDS::ObjectToken->new($o:store, $o:hash);
	$o->curlRequest('POST', $objectToken->url, []);
}

sub curlList($o, $cmd) {
	$cmd->collect($o);
	$o:keyPairToken = $o:actor->preferredKeyPairToken if ! $o:keyPairToken;
	$o:store = $o:actor->preferredStore if ! $o:store;
	$o:actorHash = $o:actor->preferredActorHash if ! $o:actorHash;

	my $boxToken = CDS::BoxToken->new(CDS::AccountToken->new($o:store, $o:actorHash), $o:boxLabel);
	my $args = ['--output', '.cds-curl-list'];
	push @$args, '-H', 'Condensation-Watch: '.$o:watchTimeout.' ms' if $o:watchTimeout;
	$o->curlRequest('GET', $boxToken->url, $args);
}

sub curlModify($o, $cmd) {
	$o:currentBatch = {
		addHashes => [],
		addEnvelopes => [],
		removeHashes => [],
		};
	$o:batches = [];
	$cmd->collect($o);
	$o:keyPairToken = $o:actor->preferredKeyPairToken if ! $o:keyPairToken;
	$o:store = $o:actor->preferredStore if ! $o:store;

	# Prepare the modifications
	my $modifications = CDS::StoreModifications->new;

	for my $batch (@$o:batches, $o:currentBatch) {
		$batch:actorHash = $o:actor->preferredActorHash if ! $batch:actorHash;

		for my $hash (@$batch:addHashes) {
			$modifications->add($batch:actorHash, $batch:boxLabel, $hash);
		}

		for my $file (@$batch:addFiles) {
			my $bytes = CDS->readBytesFromFile($file) // return $o:ui->error('Unable to read "', $file, '".');
			my $object = CDS::Object->fromBytes($bytes) // return $o:ui->error('"', $file, '" is not a Condensation object.');
			my $hash = $object->calculateHash;
			$o:ui->warning('"', $file, '" is not a valid envelope. The server may reject it.') if ! $o:actor->isEnvelope($object);
			$modifications->add($batch:actorHash, $batch:boxLabel, $hash, $object);
		}

		for my $hash (@$batch:removeHashes) {
			$modifications->remove($batch:actorHash, $batch:boxLabel, $hash);
		}
	}

	$o:ui->warning('You didn\'t specify any changes. The server should accept, but ignore this.') if $modifications->isEmpty;

	# Write a new file
	my $modificationsObject = $modifications->toRecord->toObject;
	my $modificationsHash = $modificationsObject->calculateHash;
	my $file = '.cds-curl-modifications-'.substr($modificationsHash->hex, 0, 8);
	CDS->writeBytesToFile($file, $modificationsObject->header, $modificationsObject->data) // return $o:ui->error('Unable to write modifications to "', $file, '".');
	$o:ui->line(scalar @{$modifications->additions}, ' addition(s) and ', scalar @{$modifications->removals}, ' removal(s) written to "', $file, '".');

	# Submit
	$o->curlRequest('POST', $o:store->url.'/accounts', ['--data-binary', '@'.$file, '-H', 'Content-Type: application/condensation-modifications'], $modificationsObject);
}

sub curlRequest($o, $method, $url, $curlArgs, $contentObjectToSign) {
	# Parse the URL
	$url =~ /^(https?):\/\/([^\/]+)(\/.*|)$/i || return $o:ui->error('"', $url, '" does not look like a valid and complete http://… or https://… URL.');
	my $protocol = lc($1);
	my $host = $2;
	my $path = $3;

	# Strip off user and password, if any
	my $credentials;
	if ($host =~ /^(.*)\@([^\@]*)$/) {
		$credentials = $1;
		$host = lc($2);
	} else {
		$host = lc($host);
	}

	# Remove default port
	if ($host =~ /^(.*):(\d+)$/) {
		$host = $1 if $protocol eq 'http' && $2 == 80;
		$host = $1 if $protocol eq 'https' && $2 == 443;
	}

	# Checks the path and warn the user if obvious things are likely to go wrong
	$o:ui->warning('Warning: "//" in URL may not work') if $path =~ /\/\//;
	$o:ui->warning('Warning: /./ or /../ in URL may not work') if $path =~ /\/\.+\//;
	$o:ui->warning('Warning: /. or /.. at the end of the URL may not work') if $path =~ /\/\.+$/;

	# Signature

	# Date
	my $dateString = CDS::ISODate->millisecondString(CDS->now);

	# Text to sign
	my $bytesToSign = $dateString."\0".uc($method)."\0".$host.$path;
	$bytesToSign .= "\0".$contentObjectToSign->header.$contentObjectToSign->data if defined $contentObjectToSign;

	# Signature
	my $keyPair = $o:keyPairToken->keyPair;
	my $hashToSign = CDS::Hash->calculateFor($bytesToSign);
	my $signature = $keyPair->signHash($hashToSign);
	push @$curlArgs, '-H', 'Condensation-Date: '.$dateString;
	push @$curlArgs, '-H', 'Condensation-Actor: '.$keyPair->publicKey->hash->hex;
	push @$curlArgs, '-H', 'Condensation-Signature: '.unpack('H*', $signature);

	# Write signature information to files
	CDS->writeBytesToFile('.cds-curl-bytesToSign', $bytesToSign) || $o:ui->warning('Unable to write the bytes to sign to ".cds-curl-bytesToSign".');
	CDS->writeBytesToFile('.cds-curl-hashToSign', $hashToSign->bytes) || $o:ui->warning('Unable to write the hash to sign to ".cds-curl-hashToSign".');
	CDS->writeBytesToFile('.cds-curl-signature', $signature) || $o:ui->warning('Unable to write signature to ".cds-curl-signature".');

	# Method
	unshift @$curlArgs, '-X', $method if $method ne 'GET';
	unshift @$curlArgs, '-#', '--dump-header', '-';

	# Print
	$o:ui->line($o:ui->gold('curl', join('', map { ($_ ne '-X' && $_ ne '-' && $_ ne '--dump-header' && $_ ne '-#' && substr($_, 0, 1) eq '-' ? " \\\n     " : ' ').&withQuotesIfNecessary($_) } @$curlArgs), scalar @$curlArgs ? " \\\n     " : ' ', &withQuotesIfNecessary($url)));

	# Execute
	system('curl', @$curlArgs, $url);
}

sub withQuotesIfNecessary($text) {
	return $text =~ /[^a-zA-Z0-9\.\/\@:,_-]/ ? '\''.$text.'\'' : $text;
}
